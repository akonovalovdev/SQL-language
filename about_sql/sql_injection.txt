Рекомендации:
Риск SQL-инъекций возникает всякий раз, когда программист создает динамический запрос к базе,
содержащий введённые пользователем данные. Это значит, что способов предотвращения SQL-инъекций два:
- не использовать динамические запросы к базе;
- не использовать пользовательские данные.
Поскольку отказаться от этих двух условий довольно проблематично,
то SQL-инъекции были и будут оставаться одними из самых распространенных и опасных уязвимостей веб-приложений.
И вот небольшой список рекомендаций для защиты веб-приложений от них:
- тщательная проверка данных от пользователя перед использованием их в запросе;
- отключение вывода ошибок на сервере. От SQL-инъекций это не защитит, но затруднит ее поиск и эксплуатацию;
- периодическое проведение аудита веб-приложения как вручную, так и с
помощью инструментов автоматизации (SQLmap, jSQL Injection и т.д.).
- Также можно доверить этот процесс профессионалам с достаточным опытом и уровнем подготовки;
- удаление неиспользуемого функционала. Та или иная функция, которая не была вовремя
удалена может сыграть на руку злоумышленникам;
- регулярная установка обновлений;
- использование средств защиты веб-приложений, например WAF.


Валидирование пользовательского ввода — краеугольный камень процесса безопасной разработки
Нельзя допустить выполнения в СУБД вредоносного кода, который приводит к SQL-инъекциям
Суть работы SQL-инъекций заключается во внедрении собственного
кода в SQL-запрос к базе данных с целью получить дополнительную информацию от нее
SQL-инъекция - это попытка злоумышленника изменить запрос к базе данных для ее компрометации.

Для защиты от SQL-инъекций в прикладных библиотеках PostgreSQL libpq и libpqxx
применяется техника «эскейпинг» или экранирование строки. Она заключается в том,
чтобы убрать лишние символы разрыва строк в строках, содержащих специальные символы.
С помощью этой функций символы удваиваются и более не считаются окончанием строки,
а интерпретируются как обычные символы.

Наиболее часто встречаются SQLi в SELECT запросах,
так как данный тип запросов является самым распространенным, но, все же не ограничивается только им.

SQL-injection встречается:
в строковом параметре;
в числовом параметре.

Для числового параметра характерна обработка числовых данных, например, в параметре ID:

http://example.com/index.php?id=1
Если параметр не будет иметь фильтрацию, а код выглядит примерно так:
$id = $_GET['id'];

$query = "SELECT * FROM some_table_name WHERE id=$id";
то при эксплуатации SQL-инъекции веб-приложение направит некорректный запрос в базу данных, например:

SELECT * FROM some_table_name WHERE id='1''
и в ответе от веб-приложения пользователь получит ошибку синтаксиса. Но если этого не произойдет, то здесь 2 варианта:
-SQL-инъекции здесь нет — фильтруются кавычки, или просто стоит преобразование в целочисленный тип int;
-отключен вывод ошибок.

Экранирование строки

Писать запросы в виде монолитных строк очень просто. Но иногда мы
используем запросы вида: "SELECT id FROM user WHERE name = '" + name + "'",
где используется переменная, содержащая пользовательский ввод.

Это опасно. Видите ошибку? Если переменная name будет содержать одинарные кавычки, то это может
привести к SQL-инъекции, то есть у пользователя появится возможность ввести вредоносный код,
например ".'; DROP TABLE user". Если вам повезет, это окажется просто неприятной ошибкой,
которую вы обнаруживаете, когда переменная name имеет значение "Д'Артаньян".

Итак, вам нужно экранировать переменную name перед ее вставкой.
Здесь кавычки и другие проблемные символы будут помечены как «это просто символ в строке, а не конец строки».
В libpqxx есть несколько специальных функций, которые делают это за вас.

Пример SQL-инъекции
Представьте, что вы используете следующую инструкцию SQL, где-нибудь в своей программе:

TX.exec(
        "SELECT number,amount "
        "FROM account "
        "WHERE allowed_to_see('" + userid + "','" + password + "')");

Теперь представьте, что будет, если пользователь на самом деле является злоумышленником, который знает (или может предположить) общую форму этого SQL-запроса и введет следующий пароль:

    x') OR ('x' = 'x

запрос становится:

SELECT number,amount
    FROM account
    WHERE allowed_to_see('user','x') OR ('x' = 'x')

allowed_to_see() полностью обходится выражением "OR ('x' = 'x')", которое всегда истинно.
Таким образом злоумышленник получит доступ ко всем учетным записям в базе данных!

Вот как вы можете устранить проблему в приведенном выше примере:

 TX.exec(
        "SELECT number,amount "
        "FROM account "
        "WHERE allowed_to_see('" + TX.esc(userid) + "', "
        "'" + TX.esc(password) + "')");
Теперь кавычки, встроенные в строку вредоносного кода, будут аккуратно экранированы.
Они уже не смогут «вырваться» из заключенной в кавычки строки SQL, в которую они должны были входить:

SELECT number,amount
    FROM account
    WHERE allowed_to_see('user', 'x'') OR (''x'' = ''x')

Если внимательно посмотреть, то можно увидеть, что благодаря добавленным дополнительным
эскейп-символам (в SQL одинарная кавычка экранируется путем ее удвоения) все,
что мы получаем, — это очень странно выглядящая строка пароля, но не изменение в команде SQL.

Также можно использовать метод quote для того, чтобы сразу и экранировать специальные символы,
и заключить результирующую строку в одинарные кавычки. Например, метод quote преобразует строку abc в 'abc'

__________________________________________________________________________________________________________________
Экранирование двоичных данных

Необработанные двоичные данные обрабатываются иначе, чем обычные строки. Двоичные данные
никогда не интерпретируются как текст, поэтому они могут вполне легитимно включать в себя одиночный байт
или целые последовательности байтов, которые не являются допустимыми символами в текущей кодировке символов.
Двоичная строка не заканчивается на первом нулевом байте, как в случае с текстовой строкой. Вместо этого такие строки
могут содержать нулевые байты в любом месте. Если двоичная строка содержит байты, которые выглядят,
как одинарные кавычки или что-то подобное, что может нарушить их использование в SQL-запросах,
то такие символы будут заменены на специальные эскейп-последовательности

Для использования в приложении ранее экранированных двоичных данных требуется их
обратное экранирование с помощью метода unesc_raw. Этот метод принимает двоичную строку,
ранее экранированную средствами libpqxx, и возвращает восстановленную копию исходных двоичных данных.

Дополнительные методы экранирования

Для экранирования строк-идентификаторов библиотека libpqxx предлагает нам использовать
метод quote_name. Это нужно в случае, если идентификатор,
выбранный пользователем, может содержать специальные символы, которые в противном случае
не интерпретировались бы синтаксическим анализатором SQL, как часть идентификатора. Также это может быть полезно,
когда идентификатор содержит символы верхнего регистра, и его требуется сохранить для пользователя.
Метод quote_name использует двойные кавычки в качестве символа экранирования.

Отдельно хотелось бы отметить такую функцию, как esc_like. Она подготавливает строку для использования
в LIKE части SQL-запроса. В данном случае обрабатываются спецсимволы % и _.
Например, функция esc_like преобразует строку "a%b_c" в "a\\%b\\_c".

Уменьшение угрозы SQL-инъекций
Что же сделать, чтобы митигировать угрозу SQL-инъекций при разработке ПО?
Один из подходов — сохранение чистоты типов данных. То есть если от
пользователя приходит неотрицательное число, значит, его нужно хранить в коде как unsigned и в базе как integer.
Таким образом, если мы это значение используем в запросе, нам достаточно преобразовать его к строке:

TX.exec( "SELECT name FROM account WHERE id="+std::to_string(id));
Также полезно при использовании ключевых слов SQL, таких как ASC, DESC,
AND и других, которые могут приходить от пользователя,
скажем, через URL, вообще не подставлять их в код, а использовать прием белых списков.

const std::string order = (user_data == "DESC") ? "DESC" : "ASC";
Это же можно использовать и для идентификаторов в БД, если таких идентификаторов немного.
___________________________________________________________________________________________________________
Основные методы эксплуатации SQL-injection

Union Based SQL-injection — применяется, если SQL-injection возникает в SELECT запросе.
Благодаря данному методу можно объединить два SELECT запроса в один набор результатов.
Особенность этого метода заключается в том, что он будет работать только в том случае, если количество столбцов,
возвращаемых первым запросом, будет равно количеству столбцов, возвращаемых во втором запросе.

Для определения количества столбцов можно воспользоваться 3 методами:
?id=1' union select null --
?id=1' union select null,null --
?id=1' union select null,null,null --
и т.д.

Почему используется значение NULL? Все просто, типы данных в каждом столбце должны быть совместимы между
исходным и внедренным запросами. Поскольку NULL может быть преобразован во все часто используемые типы данных,
его использование увеличивает вероятность успешного выполнения полезной нагрузки при правильном подсчете столбцов.

Использование команды order by для определение количества столбцов.
В этом случае нужно опираться на появление ошибки о несоответствии количества столбцов в запросе.
Стоит начать с большого количества столбцов и уменьшать их вдвое при каждой итерации проверки.
Если количество столбцов не будет соответствовать фактическому значению, то вернется ошибка
?id=1' order by 20 --
?id=1' order by 10 --
?id=1' order by 5 --
и т.д.

использование команды group by, который основывается на обратном методе проверки, в отличие от order by.
?id=1' group by 5 --
?id=1' group by 10 --
?id=1' group by 20 --

Boolean Based SQL-injection — метод эксплуатации слепых инъекций. Информация извлекается исходя из реакции
на условные выражения. Инъекция называется слепой в тех случаях, если нет никакой видимой реакции от веб-приложения.
Например, при подстановке кавычек в потенциально уязвимый параметр, ошибка, связанная с нарушением логики SQL-запроса,
не появляется, а страница отображается без изменений. Но тут, как уже говорилось ранее, несколько вариантов:
либо входные параметры фильтруются и уязвимости нет, либо на сервере отключен вывод ошибок на странице.
Пример:
?id=1' AND substring(@@version,1,1)=5 --
Вместе с запросом указывается некоторое условие. Условие может быть как истинным, так и ложным.
Если оба условия выполняются одновременно, то, запрос отработает корректно, в противном случае запрос не будет выполнен.

Error Based SQL-injection — данный метод позволяет получить информацию из базы данных в тексте ошибки.

Для поиска такого рода инъекций можно воспользоваться следующими примерами:
?id=0X01
?id=9999999999999999999999999999999999999999999
В первом варианте 0X01 будет являться действительным числом, но в языке PHP, а не MySQL,
что вызовет ошибку последнего. Во втором варианте число будет преобразовано в INF,
что также будет являться действительным числом для PHP, но не для MySQL.


Time Based SQL-injection — используются команды СУБД (например, sleep) , вызывающие задержку ответа от базы данных. Метод также используется для эксплуатации слепых инъекций, когда отсутствует какой-либо вывод информации, в том числе в случаях, описанных в Boolean Based SQL-injection.

Пример:

?id=1' and sleep(20) --
В этом примере добавляется задержка 20 секунд в виде команды sleep(20) для базы данных, которая создаст задержку перед ответом, что соответственно отразится и на времени ответа веб-приложения. Также для этих целей можно использовать и другие команды, например, benchmark или waitfor:

BENCHMARK(5000000,ENCODE('MSG','by 5 seconds'));
id=1' waitfor delay '00:00:10'  (MS-SQL);
pg_sleep() (PostgreSQL).
Пример, где по длительному ответу от базы данных можно определить, что первый символ значения user_password для
пользователя с id=1 будет равняться «2» т.к. char(50) является цифрой 2:

?id=1' UNION SELECT IF(SUBSTRING(user_password,1,1) =
CHAR(50),BENCHMARK(5000000,ENCODE('MSG','by 5 seconds')),null) FROM users WHERE user_id = 1;
Команда benchmark, в случае верного условия, выполнит функцию ENCODE 50000 раз,
что вызовет задержку ответа, по которой и определяется наличие SQL-инъекции.

Как искать и эксплуатировать SQLi
1. Ручной поиск. Для начала во все параметры подставляем спецсимволы:
кавычки, двойные кавычки и т.д. Если на каком-то варианте
вернулась ошибка, то инъекция найдена и можно продолжать. Как правило, используется оператор union select,
чтобы объединить сразу 2 запроса, а как мы уже знаем, этот метод требует соответствия в количестве столбцов.
С помощью order by определяем количество столбцов. После этого можно формировать запрос для получения
информации о самой базе данных. Допустим у нас столбцов будет 4, то команда будет выглядеть так:

?id=1' union select null,null,null,null --
В конце запроса обязательно ставится комментарий, например, в виде двойного дефиса. Это необходимо для того,
чтобы лишняя информация не попала в передаваемый базе данных запрос, и не нарушала его структуру.

?id=1' union select version(),user(),@@port,null --
Отправив такой запрос, мы получим версию базы данных, имя пользователя базы данных, и порт,
который использует БД (может быть полезно в случаях, когда его не удалось  определить при сканировании веб-приложения).

Автоматизация. Безусловно, навык ручного поиска и эксплуатации SQL-инъекций очень важен и порой незаменим
в тестировании на проникновение, однако и время тоже является крайне ценным ресурсом. Для его экономии,
особенно при поиске и эксплуатации слепых инъекций, разработаны вспомогательные  инструменты.

Один из них довольно популярен и называется SQLmap. Рассказывать про него особо нечего, так как это, думаю,
первая ассоциация при слове SQL-инъекция. Но если вкратце - мощный кроссплатформенный
консольный инструмент для автоматизации поиска и эксплуатации SQL-инъекций любого вида и сложности,
написанный на языке Python. В основной функционал которого входит:
полная поддержка для таких систем управления базами данных, как:  MySQL, Oracle, PostgreSQL,
Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase, SAP MaxDB и HSQLDB;
поддержка прямого подключения к базе данных без использования SQL инъекции, посредством введения учётных
данных СУБД, IP адреса, порта и имени БД;
поддержка перечисления пользователей, хешей паролей, привилегий, ролей, БД, таблиц и колонок;
автоматическое распознавание форматов хешей паролей и предложение их взлома с использованием атаки по словарю;
поддержка выполнения произвольных команд на ОС сервера БД и получение их стандартного
вывода при использовании MySQL, PostgreSQL или Microsoft SQL Server и многое другое.

Основные ключи, которые используются при работе с инструментом:
--dbs - поиск и вывод списка баз данных;
-D,T,C - указание конкретной базы данных, таблицы и колонок в таблице для дампа информации из них;
--level, --risk - параметры для более углубленного тестирования
(параметры генерируют больше трафика и могут помочь системам защиты выявить атаку);
--random-agent - использование произвольного User-Agent.

JSQL injection
Домашняя страница

Инструмент для автоматизации поиска и эксплуатации SQL-уязвимостей. Написан на Java,
поэтому является кроссплатформенным, нужно только установить нужную версию Java. Скачать jar-файл можно по ссылке.
В отличие от популярного SQLmap здесь есть графический интерфейс и инструмент
в целом может выполнять большинство всех основных действий, необходимых для поиска и эксплуатации SQL-инъекций.
______________________________________________________________________________________________________________________
Чек лист устранения инъекций( способы выявления SQLi и подробная инструкция по их ликвидации)

Возможные SQLi:
Соблюдение условия WHERE к истинному результату при любых значениях параметров.
Объединение запросов через оператор UNION.
Комментирование части запроса.

Хороший прмер исключения инъекции
$id = (int)$_GET['id'];

____________________________________________________________________________________________________________________





